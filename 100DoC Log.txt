Format: #<day number>.<attempt number>. <date>

Note: running log of progress and notes that may not be code related. Also, I'm not the best speller.

#0.1. 3/18/2018:
- Project name determined thanks to a friend

#1.1. 3/19/2018:
- Fleshing out docs and making a main function. Plan for the first couple days is to get the project started, do some parsing, how to get some values from logs, and building habits
- I'm not exactly promoting this with the hashtag right now, just to get this going. I don't feel I need motivation, just less stuff to do. I constantly have ideas and write them down, but lack the time to work on it. It makes me easy to distract, so I want to build a habit naturally with everything else I have going on before I start getting "keep going!" tweets and messages.

#2.1. 3/20/2018:
- Almost missed this day (the commit for yesterday and today say they're a day later, but it's because I start late the prior day). #HabitForming
- Already a bit overthinking it because I started trying to do streaming log parsing... just parse the log right now.
- Initial log format is XML. I'm gonna have to make a config file to determine what properties describe the log, just so the log format isn't hardcoded... but that's for a bit later. Maybe tomorrow?
- Initial plan was for a C++ program... but XML parsing, streaming logs, json parsing too (config and I'm sure someone logs in JSON) are not pleasent to work with in C++ and since I want to get something running instead of dealing with frameworks and C++ package systems, I'm just gonna start with C#

#3.1. 3/21/2018:
- I wanted to try and start processing the actual log data, so I finished the XML parsing part. Should still work on making it stream the input. Noted for later.

#4.1. 3/22/2018:
- Late commit again.
- Plan: initial orginization of log output, get streaming XML working (need option parsing so I can turn this on only if needed), have log values determined by config (requires JSON parsing)
- I started late, so I only go the first one done and will do the others tomorrow

#5.1. 3/23/2018:
- If yesterday was late, this one is later...
- I load a config file of info about parsing logs. As it's very late for me, I will test this tomorrow.
- For the "temp" C# project, I decided to be a little curious and use .Net Portable Framework. I'm kinda regretting it. So many APIs just aren't available. I get it's purpose and it should be used, but going 2 levels deep to open a StreamReader? The main library just opened one internally anyway.

#6.1. 3/24/2018:
- Late start because I was finishing something up. Wrote https://github.com/rcmaniac25/setbuilder to help with that task.
- Config for log parsing now used
- Made up a syntax (like XPath) to get out XML data... maybe I should just use XPath? Thoughts for another time
- Changed version, as this isn't 1.0 yet.
- Decided that the XML streaming is a bit too large for doing at this initial phase: why?
-- The log files I initially imagined using this on are in the multi-GB range. This inital impl. loads everything into memory, and loading one or more multi-GB logs would probabaly end poorly.
-- At the same time, I can see two uses of this system (when it reaches 1.0 status):
    1. Tracing across multiple log files.
    2. Manual "debugging" of a log.
-- In both cases, the full logs aren't needed upfront. It's like a sliding window, the system/user is only looking at one part of the log at a time to find/track something.
-- So ideally, the system should load and unload as needed. "Read the first 100 lines of logs. Ok, the user is scrolling, load the next 100. Ok, they got 1000 lines in, load another 100 and unload the first 100. Wait, they did a search... load but don't persist the logs unless it has whatever they searched for".
-- I'd assume info will be cached so it's not constantly parsing. It may be useful to do some tricks, like loading whole sections of the logs into RAM but not parsing them, that way parsing is fast when it is needed.
-- While I'm thinking about some of these things, I will eventually need logging and unit tests. I know I eventually will need to parse source code, if anything, for determining the end of a function and maybe when a function is container within the calling function. Log parsing, code parsing, etc. should all be seperate components so new ones can be used as needed...
-- ...I'm starting to overthink things. Just get some useful parsing done. Tomorrow.

#7.1. 3/25/2018:
- I did not accomplish useful parsing. Instead I refactored code, got a option parser included, and allowed XML parsing to be more "advanced" for each element instead of just the log message itself.
- PSA: Socialize. You'll get good ideas by talking with people about what you're working on. In my case, I didn't do more code (and much of anything else) because I played Fortnite for the whole day. It was fun, especially with friends.

#8.1. 3/26/2018:
- I realized to bring about the idea that's in my head, I need a better way of processing through the logs. This makes me think "database" so I can do queries, but I'm not ready for that point.
-- Basically, gather all the logs together, then do a "get by thread ID" or "get by function" or "get by <random attribute>", and then breaking it down further. Hmm... this sounds like a LINQ query. Fine will we're in .Net, but may be more difficult in C++ (unless I use Rx/Ix)
- This change "broke" the inital printout system I wrote, so I needed to get it back to the inital state it was previously at
- Had a few more log attributes that I can parse. I should look into what other loggers produce/log, so I have a general common set of values and then add some "fancy" parser for supporting log values that aren't common/custom. Also, I still haven't added support for key/value attributes and parsing types of attributes

#9.1. 3/27/2018:
- Orginized the files into folders and added one more parameter. Also fixed a bug where missing parameters could cause the program to crash
- Needed a bit of abstraction for reorginizing sources
- Just realized I finished 10 days of 100 Days of Code. Woot.

#10.1. 3/28/2018:
- Late start, but today's goal was parsing attribute types (and inadvertently formalizing the "path" syntax so I don't have to do string parsing the whole time)
- Needed to touch a little more code then I wanted... but it works, and in theory could be faster then the string parsing from before
- The path system could be expanded... but at that point, it's probably better to revisit the idea of using "paths". Speaking of which, a side reason for formalizing "paths" is because when JSON and other formats are added, we don't want to need special configs for each parser type (though we should support it...)

#11.1. 3/29/2018:
- Added key-value pair support for context attributes, which should simplify things later when we want to trace by a value
- Wasn't working... found out I forgot to actually register the attribute. Yay, copy-paste bugs

#12.1. 3/30/2018:
- Next couple days are with family, so I can't get as much done as I would like...
- Added a printer class so I can support files, console, etc. printouts without needing to rewrite systems

#13.1. 3/31/2018:
- I did one more abstraction to get the parsers and printers from a factory.
- I expect 3 reactions: why? ah, good decision, and premature optimization...
- It's not premature optmization... it's premature generalization. Something of equivilent badness, but only if it's actually going to have an effect.
- In this case, and to awnser the "why", is to shrink the classes down a bit, allow for easy testing with mocks, and to prepare for the inevitable expansion of functionality.
- See, I thought up some ideas on how I want this to operate (I should write them down in some document...), and they all revolved around the GUI. But I know some of the people who have voiced interest are CLI users. Others only use a IDE like Eclipse, VS Code, or Sublime (depending on how you set it up, it can act like an IDE...)
- I can write a single app (that I would still need to move to C++) that has tens of hundreds of options and configs, letting you do anything you wanted... or I can try and be "smart". "What file type are you using? XML? Ok, I should get the XML parser." "I'm a CLI app, so I will print to the console... wait, you specifed you wanted a file, so I will now print to a file"
- How about for "how do I know I didn't break XML parsing by switching from parser X to parser Y?" Easy: tests. But, I need to expose interfaces and internal structures to change values... or I can mock them, abstracted by interfaces, to control within the actual execution class.
- And that darn porting thing. I want this in C++ so instead of requiring *nix users to install C++, or have Java installed... or some other framework. How about "extract a program from the zip, and it runs". Like a good-old portable app.
- Here's what now happens:
-- 1. Bunch of small classes, as independent functionality and decision making is broken up, makes it easier to port eventually. It also allows for making focused classes, such as one that says "what do we need to parse" and "how do we need to present it" instead of a giant code block that's all tangled together.
-- 2. Tests now can be more complex, test more functionality because it doesn't have to test functions with 30 if statements in them, and actually be written without modifying the real code. Need to start this while things are small...
-- 3. Lastly, every time I say "let me add a new feature", I don't have to "make it fit". I should have a class that defines that functionnal "idea" and where it fits in.
- TL:DR: I didn't need to do this now, but it will be easier now then when the code is already tangled.

#14.1. 4/1/2018:
- Moved a couple classes that I didn't get to yesterday, since the factories imply the internal/implementation details don't need to know. Trust the interface.
- PSA: don't kill yourself coding. It's never worth it. Take it from my own experience: I keep wanting to get a bunch of stuff done, and end up staying up late. Doing that and getting up late, so you get the sleep, is fine (so long as work, school, whatever is your real life allows it). In my case, I have been getting what I mentally averaged to 4-5 hours a sleep a night... for like 6+ months. It's made me more tired, sluggish, harder to focus, and I've gotten more sick then I'm used to. I need to break this habit...
- ...which brings me to: I'm sick and need rest. So I did an additional refactor which got rid of a redudent class, though at the detriment of being able to insert mocks easily... (didn't I write about this yesterday?). I will probably reintroduce the class or an equiv. component.
- For now, I sleep. Tomorrow, I'd like to plan further moves and maybe get a public list of tasks I'm trying to do.

#15.1. 4/2/2018:
- PSA: being sick is annoying. Take care of yourself.
- Today I worked on docs... a needed evil

#16.1. 4/3/2018:
- More doc work. I had a timeline to follow, but it was agressive when I wrote it, and probably can't do such a thing (and ideas for how/what to do also became more concrete between then and now). Simplified:
-- Day 1. figure out program name
-- Day 25. Have a library that can parse a large-ish log quickly
-- Day 50. Initial GUI that can visually show the flow of the logs
-- Day 75. Have a working library for parsing, GUI for visually debugging through the logs, support for RPCs and message tracing, have let others (I know directly) try it out and see what they think and what they want/have issues with, and start working on an offical CLI and search capability
-- Day 100. Version 1.0, with a bit of polish, integration with a real debugger (at the time, I assumed to augment a debugger with log info... but I'm not sure how much that would actually be needed), and possibly work on any stretch goals I could think of along the way.
- Talk about agressive...

#17.1. 4/4/2018:
- Thought a bit and opted to just split the program and library portions. There was no good abstract interface that would allow unit testing AND be usable by more then just one class/program.
- Instead decided to start trying to get unit tests setup, starting with spliting the program and library.