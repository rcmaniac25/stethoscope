using Stethoscope.Common;

using System;
using System.Collections.Generic;
using System.IO;

namespace Stethoscope.Printers.Internal.PrintMode
{
    /// <summary>
    /// Ordered list of processaable print mode values.
    /// </summary>
    public class PrintModeFormat
    {
        private IConditional logConditional;
        private ICollection<IElement> elements;

        /// <summary>
        /// When processing a log, write directly to the specified writer.
        /// If enabled, it may result in some logs being partially written out, depending on modifiers.
        /// </summary>
        public bool DirectWrite { get; set; }

        /// <summary>
        /// The newline to use at the end of each <see cref="Process(TextWriter, ILogEntry, object)"/>.
        /// <c>null</c> uses the standard newline operator as the <see cref="TextWriter"/> specifies. Anything else, including "", will be printed at the end of the process.
        /// </summary>
        public string NewLine { get; set; }

        /// <summary>
        /// Set the print mode value to use. This will reset any existing print mode values.
        /// </summary>
        /// <param name="mode">The print mode to use.</param>
        /// <param name="printer">The printer that will be using the print mode.</param>
        public void SetMode(string mode, IPrinter printer)
        {
            if (mode == null)
            {
                throw new ArgumentNullException(nameof(mode));
            }

            logConditional = null;
            elements = null;

            var factory = printer.ElementFactory ?? new ElementFactory();
            var parser = PrintModeParser.Parse(mode, factory);

            logConditional = parser.GlobalConditional;
            elements = parser;
        }

        /// <summary>
        /// Evaluate the the format that has been set to determine if <see cref="DirectWrite"/> can be used.
        /// </summary>
        public void UpdateDirectWrite()
        {
            DirectWrite = true; //XXX until we can distinguish elements, we won't know if direct write is possible or not. Until then, it's fine (as nothing's implemented that would make direct write problematic)
#if false
            foreach (var element in elements)
            {
                //TODO: check for failure handlers and what might happen
            }
#endif
        }

        /// <summary>
        /// Process an individual log with the stored print mode values.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="log">The log to process.</param>
        /// <param name="state">The state generated by <see cref="GenerateStateObject"/></param>
        public void Process(TextWriter writer, ILogEntry log, object state)
        {
            if (writer == null)
            {
                throw new ArgumentNullException(nameof(writer));
            }
            if (log == null)
            {
                throw new ArgumentNullException(nameof(log));
            }

            var innerState = (object[])state;
            var innerStateCurrentIndex = logConditional == null ? 0 : 1;
            if (innerState.Length != (elements.Count + innerStateCurrentIndex))
            {
                throw new InvalidOperationException("State is not compatible with this PrintMode. The format may have changed between GenerateStateObject and Process.");
            }

            var directWrite = DirectWrite; // Precaution if value is changed mid-write. Weird, but is plausible and cheap to handle
            var logWriter = directWrite ? writer : new StringWriter() { NewLine = writer.NewLine };

            /* Steps:
             * 1. evaluate log-level conditional
             * 2. Iterate over all format parts
             * 3. Execute part (writing occurs to a buffer)
             *     a. If raw, print. If not raw, evaluate conditional
             *     b. if conditional passes, print value (using modifiers if need-be) and notify conditional
             *     c. FUTURE-TODO: if conditional fails, and a failed conditional modifier exists, invoke it
             *     d. if exception occurs, invoke failure handler modifier if it exists
             *  4. Flush buffer to actual text writer
             */
            
            // #1
            if (logConditional != null)
            {
                if (!logConditional.ShouldProcess(log, innerState[0]))
                {
                    return;
                }
            }

            // #2
            foreach (var element in elements)
            {
                // #3
                try
                {
                    element.Process(logWriter, log, innerState[innerStateCurrentIndex++]);
                }
                catch (Exception e)
                {
                    if (element.ExceptionHandler == null)
                    {
                        if (e is PrintException pe)
                        {
                            // Default exception handler
                            logWriter.Write("{{{0}}}", e.Message);
                            continue;
                        }
                        throw e;
                    }
                    element.ExceptionHandler.HandleException(e, log, element); //XXX needs modifications (um, what would it print to?)
                }
            }

            if (logConditional != null)
            {
                innerState[0] = logConditional.Processed(log, innerState[0]);
            }

            if (NewLine != null)
            {
                logWriter.Write(NewLine);
            }
            else
            {
                logWriter.WriteLine();
            }

            // #4
            if (!directWrite)
            {
                writer.Write(((StringWriter)logWriter).ToString());
                writer.Flush();
            }
        }

        /// <summary>
        /// Generate the state values necessary for <see cref="Process(TextWriter, ILogEntry, object)"/> to run.
        /// </summary>
        /// <returns>Generated state object.</returns>
        public object GenerateStateObject()
        {
            var index = logConditional == null ? 0 : 1;
            var state = new object[elements.Count + index];

            if (logConditional != null)
            {
                state[0] = logConditional.GenerateState();
            }
            foreach (var element in elements)
            {
                state[index++] = element.GenerateStateObject();
            }

            return state;
        }
    }
}
